<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zadania szachowe</title>

<style>
:root {
  --light: #f0d9b5;
  --dark: #b58863;
  --highlight: #baca44;
  --move-from: #cdd26a;
  --move-to: #aaa23a;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: system-ui, Arial, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
}

header {
  background: rgba(0,0,0,0.8);
  color: #fff;
  text-align: center;
  padding: 2rem 1rem;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

header h1 {
  margin: 0 0 0.5rem 0;
  font-size: 2.5rem;
}

header p {
  margin: 0;
  opacity: 0.9;
}

.container {
  max-width: 1000px;
  margin: 2rem auto;
  background: #fff;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.2);
}

.puzzle-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  flex-wrap: wrap;
  gap: 1rem;
}

.puzzle-info {
  flex: 1;
}

.puzzle-info h2 {
  margin: 0 0 0.5rem 0;
  color: #333;
}

.puzzle-info p {
  margin: 0;
  color: #666;
}

.difficulty {
  display: inline-block;
  padding: 0.3rem 0.8rem;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: bold;
  margin-top: 0.5rem;
}

.difficulty.easy { background: #d4edda; color: #155724; }
.difficulty.medium { background: #fff3cd; color: #856404; }
.difficulty.hard { background: #f8d7da; color: #721c24; }

.game-status {
  text-align: center;
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: 8px;
  font-weight: bold;
  font-size: 1.1rem;
  background: #e3f2fd;
  color: #1976d2;
  transition: all 0.3s;
}

.game-status.success {
  background: #d4edda;
  color: #155724;
}

.game-status.error {
  background: #f8d7da;
  color: #721c24;
}

.board-container {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 2rem 0;
}

.board-wrapper {
  display: inline-block;
  position: relative;
  padding: 20px;
}

.board {
  display: grid;
  grid-template-columns: repeat(8, 60px);
  grid-template-rows: repeat(8, 60px);
  border: 3px solid #333;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  transition: transform 0.1s;
  position: relative;
}

.board.disabled {
  pointer-events: none;
  opacity: 0.7;
}

.square {
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.square.light { background: var(--light); }
.square.dark { background: var(--dark); }

.square.last-move-from {
  background: var(--move-from) !important;
}

.square.last-move-to {
  background: var(--move-to) !important;
}

.square.drag-over {
  box-shadow: inset 0 0 0 3px var(--highlight);
}

.square.possible-move::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  background: rgba(0,0,0,0.15);
  border-radius: 50%;
  pointer-events: none;
}

.square.possible-capture::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 100%;
  border: 3px solid rgba(0,0,0,0.2);
  border-radius: 50%;
  pointer-events: none;
}

.piece {
  font-size: 48px;
  user-select: none;
  line-height: 1;
  cursor: grab;
  transition: transform 0.1s;
  z-index: 10;
}

.piece.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.piece:active {
  cursor: grabbing;
}

.coords {
  position: absolute;
  font-size: 11px;
  font-weight: bold;
  pointer-events: none;
  z-index: 5;
}

.file-coord {
  bottom: 2px;
  right: 3px;
}

.rank-coord {
  top: 2px;
  left: 3px;
}

.square.light .coords { color: var(--dark); }
.square.dark .coords { color: var(--light); }

.controls {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
  flex-wrap: wrap;
  justify-content: center;
}

button {
  padding: 0.8rem 1.5rem;
  background: #667eea;
  color: #fff;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 600;
  transition: all 0.3s;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

button:hover:not(:disabled) {
  background: #5568d3;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

button:active:not(:disabled) {
  transform: translateY(0);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button.secondary {
  background: #6c757d;
}

button.secondary:hover:not(:disabled) {
  background: #5a6268;
}

button.success {
  background: #28a745;
}

button.success:hover:not(:disabled) {
  background: #218838;
}

.move-list {
  margin-top: 1rem;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 8px;
  min-height: 60px;
}

.move-list h4 {
  margin: 0 0 0.5rem 0;
  color: #495057;
}

.move-list .moves {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.move-list .move {
  padding: 0.3rem 0.6rem;
  background: #fff;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  font-family: monospace;
}

.stats {
  text-align: center;
  margin-top: 1rem;
  padding: 1rem;
  background: #f8f9fa;
  border-radius: 8px;
}

.stats span {
  display: inline-block;
  margin: 0 1rem;
  font-weight: bold;
  color: #495057;
}

footer {
  text-align: center;
  padding: 2rem 1rem;
  color: rgba(255,255,255,0.8);
  font-size: 0.9rem;
}

@media (max-width: 768px) {
  .board {
    grid-template-columns: repeat(8, 45px);
    grid-template-rows: repeat(8, 45px);
  }
  
  .piece {
    font-size: 36px;
  }
  
  header h1 {
    font-size: 2rem;
  }
  
  .container {
    margin: 1rem;
    padding: 1.5rem;
  }
}
</style>
</head>

<body>

<header>
  <h1>‚ôüÔ∏è Zadania Szachowe</h1>
  <p>ƒÜwicz taktykƒô i popraw swojƒÖ grƒô</p>
</header>

<div class="container">
  <div class="puzzle-header">
    <div class="puzzle-info">
      <h2 id="puzzleTitle">Zadanie 1: Mat w 1</h2>
      <p id="puzzleDescription">Bia≈Çe zaczynajƒÖ i dajƒÖ mata.</p>
      <span class="difficulty easy" id="puzzleDifficulty">≈Åatwy</span>
    </div>
  </div>

  <div id="gameStatus" class="game-status">Twoja kolej - wykonaj najlepszy ruch!</div>

  <div class="board-container">
    <div class="board-wrapper">
      <div id="board" class="board"></div>
    </div>
  </div>

  <div class="move-list">
    <h4>üìù Historia ruch√≥w:</h4>
    <div id="moveHistory" class="moves"></div>
  </div>

  <div class="controls">
    <button id="hintBtn" onclick="showHint()">üí° Podpowied≈∫</button>
    <button class="secondary" onclick="resetPuzzle()">üîÑ Reset zadania</button>
    <button class="secondary" onclick="nextPuzzle()">‚û°Ô∏è Nastƒôpne zadanie</button>
  </div>

  <div class="stats">
    <span>üìä Zadanie: <span id="puzzleNumber">1</span> / 3</span>
    <span>‚úÖ RozwiƒÖzane: <span id="solvedCount">0</span></span>
  </div>
</div>

<footer>¬© 2025 Zadania Szachowe | Ucz siƒô i rozwijaj swoje umiejƒôtno≈õci</footer>

<script>
const pieces = {
  "wK": "‚ôî", "wQ": "‚ôï", "wR": "‚ôñ", "wB": "‚ôó", "wN": "‚ôò", "wP": "‚ôô",
  "bK": "‚ôö", "bQ": "‚ôõ", "bR": "‚ôú", "bB": "‚ôù", "bN": "‚ôû", "bP": "‚ôü"
};

const puzzles = [
  {
    title: "Zadanie 1: Mat w 1",
    description: "Bia≈Çe zaczynajƒÖ i dajƒÖ mata.",
    difficulty: "easy",
    initialPosition: {
      "e1": "wK",
      "d8": "wQ",
      "e8": "bK",
      "f7": "bP",
      "g7": "bP"
    },
    solution: [
      { from: "d8", to: "d7", piece: "wQ" }
    ],
    explanation: "Hetman na d7 daje mata - kr√≥l na e8 jest zablokowany w≈Çasnymi pionkami na f7 i g7."
  },
  {
    title: "Zadanie 2: Mat w 2",
    description: "Bia≈Çe zaczynajƒÖ. Znajd≈∫ sekwencjƒô matujƒÖcƒÖ.",
    difficulty: "medium",
    initialPosition: {
      "e1": "wK",
      "a1": "wR",
      "h1": "wR",
      "e8": "bK",
      "f7": "bP",
      "g7": "bP",
      "h7": "bP"
    },
    solution: [
      { from: "a1", to: "a8", piece: "wR" },
      { from: "e8", to: "f7", piece: "bK" },
      { from: "h1", to: "h7", piece: "wR" }
    ],
    explanation: "1. Ra8+ wymusza Kf7 (jedyne pole). 2. Rh7# - mat!"
  },
  {
    title: "Zadanie 3: Widelec",
    description: "Bia≈Çe wykonujƒÖ widelec i wygrywajƒÖ hetmana.",
    difficulty: "medium",
    initialPosition: {
      "e1": "wK",
      "f3": "wN",
      "e8": "bK",
      "d5": "bQ",
      "f6": "bB"
    },
    solution: [
      { from: "f3", to: "g5", piece: "wN" },
      { from: "e8", to: "d8", piece: "bK" },
      { from: "g5", to: "d5", piece: "wN" }
    ],
    explanation: "Ng5 atakuje kr√≥la i hetmana. Po ruchu kr√≥la, zbijamy hetmana."
  }
];

let currentPuzzle = 0;
let solvedPuzzles = new Set();
let currentPosition = {};
let moveHistory = [];
let solutionIndex = 0;
let isPlayerTurn = true;

const files = ["a","b","c","d","e","f","g","h"];

let draggedPiece = null;
let draggedFrom = null;
let touchStartX = 0;
let touchStartY = 0;

function resetPuzzle() {
  const puzzle = puzzles[currentPuzzle];
  currentPosition = JSON.parse(JSON.stringify(puzzle.initialPosition));
  moveHistory = [];
  solutionIndex = 0;
  isPlayerTurn = true;
  updateGameStatus("Twoja kolej - wykonaj najlepszy ruch!", "");
  renderBoard();
  updateMoveHistory();
  document.getElementById("board").classList.remove("disabled");
}

function renderBoard() {
  const board = document.getElementById("board");
  board.innerHTML = "";

  for (let rank = 8; rank >= 1; rank--) {
    for (let file = 0; file < 8; file++) {
      const square = document.createElement("div");
      const isLight = (rank + file) % 2 === 0;
      square.className = `square ${isLight ? "light" : "dark"}`;

      const coord = files[file] + rank;
      square.dataset.coord = coord;
      
      if (file === 7) {
        const rankCoord = document.createElement("div");
        rankCoord.className = "coords rank-coord";
        rankCoord.textContent = rank;
        square.appendChild(rankCoord);
      }
      if (rank === 1) {
        const fileCoord = document.createElement("div");
        fileCoord.className = "coords file-coord";
        fileCoord.textContent = files[file];
        square.appendChild(fileCoord);
      }

      // Highlight last move
      if (moveHistory.length > 0) {
        const lastMove = moveHistory[moveHistory.length - 1];
        if (coord === lastMove.from) square.classList.add("last-move-from");
        if (coord === lastMove.to) square.classList.add("last-move-to");
      }

      if (currentPosition[coord]) {
        const piece = document.createElement("div");
        piece.className = "piece";
        piece.textContent = pieces[currentPosition[coord]];
        piece.draggable = true;
        piece.dataset.coord = coord;
        piece.dataset.piece = currentPosition[coord];
        
        // Only allow dragging white pieces on player's turn
        const isWhitePiece = currentPosition[coord].startsWith('w');
        if (!isWhitePiece || !isPlayerTurn) {
          piece.draggable = false;
          piece.style.cursor = "default";
        } else {
          piece.addEventListener("dragstart", handleDragStart);
          piece.addEventListener("dragend", handleDragEnd);
          piece.addEventListener("touchstart", handleTouchStart);
          piece.addEventListener("touchmove", handleTouchMove);
          piece.addEventListener("touchend", handleTouchEnd);
        }
        
        square.appendChild(piece);
      }
      
      square.addEventListener("dragover", handleDragOver);
      square.addEventListener("drop", handleDrop);
      square.addEventListener("dragleave", handleDragLeave);

      board.appendChild(square);
    }
  }
}

function handleDragStart(e) {
  if (!isPlayerTurn) return;
  draggedPiece = e.target;
  draggedFrom = e.target.dataset.coord;
  e.target.classList.add("dragging");
  e.dataTransfer.effectAllowed = "move";
}

function handleDragEnd(e) {
  e.target.classList.remove("dragging");
  document.querySelectorAll(".square").forEach(sq => {
    sq.classList.remove("drag-over");
  });
}

function handleDragOver(e) {
  if (!isPlayerTurn) return;
  e.preventDefault();
  e.dataTransfer.dropEffect = "move";
  e.currentTarget.classList.add("drag-over");
}

function handleDragLeave(e) {
  e.currentTarget.classList.remove("drag-over");
}

function handleDrop(e) {
  if (!isPlayerTurn) return;
  e.preventDefault();
  e.currentTarget.classList.remove("drag-over");
  
  const targetSquare = e.currentTarget;
  const targetCoord = targetSquare.dataset.coord;
  
  if (draggedFrom !== targetCoord) {
    makeMove(draggedFrom, targetCoord);
  }
  
  draggedPiece = null;
  draggedFrom = null;
}

function handleTouchStart(e) {
  if (!isPlayerTurn) return;
  const touch = e.touches[0];
  draggedPiece = e.target;
  draggedFrom = e.target.dataset.coord;
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  
  e.target.classList.add("dragging");
  e.preventDefault();
}

function handleTouchMove(e) {
  if (!isPlayerTurn) return;
  e.preventDefault();
  const touch = e.touches[0];
  
  const elementUnderFinger = document.elementFromPoint(touch.clientX, touch.clientY);
  document.querySelectorAll(".square").forEach(sq => sq.classList.remove("drag-over"));
  
  if (elementUnderFinger && elementUnderFinger.classList.contains("square")) {
    elementUnderFinger.classList.add("drag-over");
  } else if (elementUnderFinger && elementUnderFinger.closest(".square")) {
    elementUnderFinger.closest(".square").classList.add("drag-over");
  }
}

function handleTouchEnd(e) {
  if (!isPlayerTurn) return;
  e.preventDefault();
  draggedPiece.classList.remove("dragging");
  
  const touch = e.changedTouches[0];
  const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
  
  let targetSquare = null;
  if (targetElement && targetElement.classList.contains("square")) {
    targetSquare = targetElement;
  } else if (targetElement && targetElement.closest(".square")) {
    targetSquare = targetElement.closest(".square");
  }
  
  document.querySelectorAll(".square").forEach(sq => sq.classList.remove("drag-over"));
  
  if (targetSquare && targetSquare.dataset.coord) {
    const targetCoord = targetSquare.dataset.coord;
    if (draggedFrom !== targetCoord) {
      makeMove(draggedFrom, targetCoord);
    }
  }
  
  draggedPiece = null;
  draggedFrom = null;
}

function makeMove(fromCoord, toCoord) {
  const piece = currentPosition[fromCoord];
  if (!piece) return;

  const puzzle = puzzles[currentPuzzle];
  const expectedMove = puzzle.solution[solutionIndex];

  // Check if this is the correct move
  if (expectedMove.from === fromCoord && expectedMove.to === toCoord) {
    // Correct move!
    currentPosition[toCoord] = piece;
    delete currentPosition[fromCoord];
    
    moveHistory.push({
      from: fromCoord,
      to: toCoord,
      piece: piece,
      notation: getPieceNotation(piece) + toCoord
    });
    
    solutionIndex++;
    renderBoard();
    updateMoveHistory();
    
    // Check if puzzle is complete
    if (solutionIndex >= puzzle.solution.length) {
      puzzleSolved();
    } else {
      // Check if next move is opponent's
      const nextMove = puzzle.solution[solutionIndex];
      if (nextMove.piece.startsWith('b')) {
        // Opponent's turn
        isPlayerTurn = false;
        updateGameStatus("Przeciwnik my≈õli...", "");
        setTimeout(() => makeOpponentMove(), 800);
      } else {
        updateGameStatus("≈öwietnie! Wykonaj nastƒôpny ruch.", "success");
      }
    }
  } else {
    // Wrong move
    updateGameStatus("To nie jest najlepszy ruch! Spr√≥buj ponownie.", "error");
    animateWrongMove();
  }
}

function makeOpponentMove() {
  const puzzle = puzzles[currentPuzzle];
  const move = puzzle.solution[solutionIndex];
  
  currentPosition[move.to] = move.piece;
  delete currentPosition[move.from];
  
  moveHistory.push({
    from: move.from,
    to: move.to,
    piece: move.piece,
    notation: getPieceNotation(move.piece) + move.to
  });
  
  solutionIndex++;
  renderBoard();
  updateMoveHistory();
  
  // Check if puzzle is complete
  if (solutionIndex >= puzzle.solution.length) {
    puzzleSolved();
  } else {
    isPlayerTurn = true;
    updateGameStatus("Twoja kolej - wykonaj najlepszy ruch!", "");
  }
}

function getPieceNotation(piece) {
  const notation = {
    'wK': 'K', 'wQ': 'Q', 'wR': 'R', 'wB': 'B', 'wN': 'N', 'wP': '',
    'bK': 'K', 'bQ': 'Q', 'bR': 'R', 'bB': 'B', 'bN': 'N', 'bP': ''
  };
  return notation[piece] || '';
}

function puzzleSolved() {
  isPlayerTurn = false;
  solvedPuzzles.add(currentPuzzle);
  updateGameStatus("üéâ Gratulacje! Zadanie rozwiƒÖzane poprawnie!", "success");
  document.getElementById("solvedCount").textContent = solvedPuzzles.size;
  document.getElementById("board").classList.add("disabled");
}

function animateWrongMove() {
  const board = document.getElementById("board");
  board.style.transform = "translateX(-10px)";
  setTimeout(() => { board.style.transform = "translateX(10px)"; }, 100);
  setTimeout(() => { board.style.transform = "translateX(0)"; }, 200);
}

function updateGameStatus(message, type) {
  const status = document.getElementById("gameStatus");
  status.textContent = message;
  status.className = "game-status";
  if (type) status.classList.add(type);
}

function updateMoveHistory() {
  const historyEl = document.getElementById("moveHistory");
  historyEl.innerHTML = "";
  
  moveHistory.forEach((move, i) => {
    const moveEl = document.createElement("span");
    moveEl.className = "move";
    moveEl.textContent = `${Math.floor(i/2) + 1}${i % 2 === 0 ? '.' : '...'} ${move.notation}`;
    historyEl.appendChild(moveEl);
  });
  
  if (moveHistory.length === 0) {
    historyEl.innerHTML = '<span style="color: #999;">Brak ruch√≥w</span>';
  }
}

function updatePuzzleInfo() {
  const puzzle = puzzles[currentPuzzle];
  document.getElementById("puzzleTitle").textContent = puzzle.title;
  document.getElementById("puzzleDescription").textContent = puzzle.description;
  document.getElementById("puzzleDifficulty").textContent = 
    puzzle.difficulty === "easy" ? "≈Åatwy" : puzzle.difficulty === "medium" ? "≈öredni" : "Trudny";
  document.getElementById("puzzleDifficulty").className = `difficulty ${puzzle.difficulty}`;
  document.getElementById("puzzleNumber").textContent = currentPuzzle + 1;
  document.getElementById("solvedCount").textContent = solvedPuzzles.size;
}

function showHint() {
  if (!isPlayerTurn) return;
  
  const puzzle = puzzles[currentPuzzle];
  const nextMove = puzzle.solution[solutionIndex];
  
  updateGameStatus(`üí° Podpowied≈∫: Przesu≈Ñ ${getPieceName(nextMove.piece)} z ${nextMove.from} na ${nextMove.to}`, "");
  
  // Highlight the piece and target square
  document.querySelectorAll(".square").forEach(sq => {
    if (sq.dataset.coord === nextMove.from || sq.dataset.coord === nextMove.to) {
      sq.style.boxShadow = "inset 0 0 0 3px #ffeb3b";
      setTimeout(() => { sq.style.boxShadow = ""; }, 2000);
    }
  });
}

function getPieceName(piece) {
  const names = {
    'wK': 'kr√≥la', 'wQ': 'hetmana', 'wR': 'wie≈ºƒô', 'wB': 'go≈Ñca', 'wN': 'skoczka', 'wP': 'piona',
    'bK': 'kr√≥la', 'bQ': 'hetmana', 'bR': 'wie≈ºƒô', 'bB': 'go≈Ñca', 'bN': 'skoczka', 'bP': 'piona'
  };
  return names[piece] || 'figurƒô';
}

function nextPuzzle() {
  currentPuzzle = (currentPuzzle + 1) % puzzles.length;
  resetPuzzle();
  updatePuzzleInfo();
}

// Initialize
resetPuzzle();
updatePuzzleInfo();
</script>

</body>
</html>
